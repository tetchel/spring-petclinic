name: E2E OpenShift Pet Clinic Buildah Workflow
on: [ push, workflow_dispatch ]
env:
  IMAGE_REGISTRY: quay.io
  QUAY_USER: tetchell
  IMAGE_NAME: petclinic
  APP_PORT: 8080

jobs:
  ####################################################################################################
  compile:
    name: Compile
    runs-on: ubuntu-20.04
    outputs:
      jarname: ${{ steps.get-jarname.outputs.jarname }}
    env:
      TARGET_DIR: target/
    steps:
    - uses: actions/checkout@v2

    - name: Hash source files
      # Hash all files other than those we expicitly ignore here, which would have no effect on the output jar.
      run: |
        echo "SRC_HASH=${{ hashFiles('**', '!.git/**', '!readme.md', '!docker-compose.yml', '!.gitignore', '!.vscode/**', '!.github/**', '!manifests/**') }}" >> $GITHUB_ENV

    - name: Look for existing cache
      uses: actions/cache@v2
      id: check-target-cached
      with:
        path: ${{ env.TARGET_DIR }}
        key: ${{ env.SRC_HASH }}

    # If the cache lookup failed, we have to build the jar.
    - name: Setup Java
      uses: actions/setup-java@v1
      with:
        java-version: 11
      if: steps.check-target-cached.outputs.cache-hit != 'true'

    - run: java -version
      if: steps.check-target-cached.outputs.cache-hit != 'true'

    - run: mvn -ntp -B package
      if: steps.check-target-cached.outputs.cache-hit != 'true'

    # If there was no cache hit above, store the output into the cache now.
    - name: Update cache
      uses: actions/cache@v2
      if: steps.check-target-cached.outputs.cache-hit != 'true'
      with:
        path: ${{ env.TARGET_DIR }}
        key: ${{ env.SRC_HASH }}

    # The jar has now been either built, or retrieved from teh cache.

    # Store the output jar into the env for reuse below.
    # It will contain, eg. "spring-petclinic-2.3.0.BUILD-SNAPSHOT.jar"
    - name: Get jar filename
      id: get-jarname
      run: |
        export JAR_NAME="$(basename $(ls target/*.jar))"
        echo "Petclinic jar is $JAR_NAME"
        echo "::set-output name=jarname::$JAR_NAME"
        echo "JAR_NAME=$JAR_NAME" >> $GITHUB_ENV

    - uses: actions/upload-artifact@v2
      with:
        name: ${{ env.JAR_NAME }}
        path: ${{ env.TARGET_DIR }}/${{ env.JAR_NAME }}
        if-no-files-found: error

  ####################################################################################################
  build-push-image:
    name: Build and Push to Quay
    runs-on: ubuntu-20.04
    needs: compile
    outputs:
      image_url: ${{ steps.resolve_image_url.outputs.image_url }}
      image_tag: ${{ steps.set_tag.outputs.image_tag }}
    env:
      JAR_NAME: ${{ needs.compile.outputs.jarname }}
      IMAGE_TAG: latest
    steps:
      - uses: actions/download-artifact@v2
        with:
          name: ${{ env.JAR_NAME }}

      - name: Set image tag
        id: set_tag
        run: |
          export IMAGE_TAG=latest
          export REF="${{ github.ref }}"
          if [[ $REF =~ "refs/tags/" ]]; then
            echo "Tag workflow detected"
            # it is a tag, so we set the image tag to the git tag
            export IMAGE_TAG=${REF/refs\/tags\/}
          else
            echo "Not a tag workflow"
          fi
          echo "Tag is $IMAGE_TAG"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "::set-output name=image_tag::$IMAGE_TAG"

      - name: Build Image
        uses: redhat-actions/buildah-action@main
        with:
          new-image-name: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          base-image: docker.io/fabric8/java-alpine-openjdk11-jre
          content: ${{ env.JAR_NAME }}
          entrypoint: |
            java
            -jar
            ${{ env.JAR_NAME }}
          port: ${{ env.CONTAINER_PORT }}

      - name: Push to Quay
        uses: redhat-actions/push-to-registry@v1
        with:
          image: ${{ env.IMAGE_NAME }}
          tag: ${{ env.IMAGE_TAG }}
          registry: ${{ env.IMAGE_REGISTRY }}/${{ env.QUAY_USER }}
          username: ${{ env.QUAY_USER }}
          password: ${{ secrets.QUAY_PASSWORD }}

      - name: Resolve image URL
        id: resolve_image_url
        run: |
          echo "::set-output name=image_url::${{ env.IMAGE_REGISTRY }}/${{ env.QUAY_USER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

  ####################################################################################################
  openshift-deploy:
    name: Deploy on OpenShift
    runs-on: ubuntu-20.04
    needs: build-push-image
    defaults:
      run:
        working-directory: manifests
    env:
      TEST_NAMESPACE: tetchell-code
      BUILT_MANIFEST: petclinic.yml
      IMAGE_URL: ${{ needs.build-push-image.outputs.image_url }}
      VERSION: ${{ needs.build-push-image.outputs.image_tag }}

    steps:
      - uses: actions/checkout@v2

      - name: Generate kustomize patch
        run: |
          echo "::group::Generated patch file"
          envsubst < patch.template.yml | tee patch.yml
          echo "::endgroup::"
          echo "::group::Generated manifest"
          kustomize build . | tee ${{ env.BUILT_MANIFEST }}
          echo "::endgroup::"

      - name: Upload manifest
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.BUILT_MANIFEST }}
          path: manifests/${{ env.BUILT_MANIFEST }}
          if-no-files-found: error

      - name: OpenShift Login
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.SANDBOX_URL }}
          openshift_token: ${{ secrets.SANDBOX_TOKEN }}
          insecure_skip_tls_verify: true
          namespace: ${{ env.TEST_NAMESPACE }}

      - name: Apply manifest
        id: apply-manifest
        run: oc apply -f ${{ env.BUILT_MANIFEST }}

      - name: View deployed resources
        run: oc get -f ${{ env.BUILT_MANIFEST }}

      - name: Get public route
        run: |
          export HOST=$(oc get route petclinic -o jsonpath='{.spec.host}')
          [[ -n $HOST ]]   # Check non-empty
          export PROJECT_ROUTE=http://$HOST
          echo "Project route is $PROJECT_ROUTE"
          echo "PROJECT_ROUTE=$PROJECT_ROUTE" >> $GITHUB_ENV

      - name: Pause to allow pod to come up
        run: sleep 10

      - name: Test project is running
        uses: nick-invision/retry@v2.2.0
        with:
          timeout_seconds: 5
          retry_wait_seconds: 10
          max_attempts: 6
          warning_on_retry: false
          command: curl -sSfLi ${{ env.PROJECT_ROUTE }}

      - name: Clean up deployed resources
        if: always() && ${{ steps.apply-manifest.outcome }} == 'success'
        run: oc delete -f ${{ env.BUILT_MANIFEST }}
